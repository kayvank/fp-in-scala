#+startup: beamer
#+LaTeX_CLASS: beamer
#+BEAMER_FRAME_LEVEL: 2

* functional programming in Scala notes
  Yet another review of the [[https://www.manning.com/books/functional-programming-in-scala][fp in scala]]
** § 1
*** Referential Transparency, RT
    forces the invariant that everything a function does is represented by a value that is returned.
**** RT enables equational reasoning
*** Pure function 
** § 2
*** Polymorphic functions 
**** abstracting over types
     these are functions that work for any given type, also known as parametric polymorphism 
**** type parameters & type variable
** § 3
   Functional data structure
*** when function definition contains multiple argument groups, type info flows from left to right across args group
**** form [[http://www.cs.nott.ac.uk/~pszgmh/fold.pdf][fold]]
** § 4
   Handling errors without Exceptions
*** Variance 
    refers to how subtyping between more complex types relates to subtyping between their components 
*** covariant 
    subtyping relation of the simple types are preserved for the more complex types
*** contravariant
    The subtyping relationship is reversed for the more complex types
*** Option
**** lift functions to operate on Option
     def lift[A, B](f: A=>B): Option[A] => Option[B] = _ map f 
*** Either
**** used when Option is too simplistic for the use case
**** represent failure & exceptions with ordinary values
**** how: 
***** craft data type that encodes failure
***** _disjoint union_ of two types
** § 5
   Strickness & lazyness
*** Non-strickness
    to say a function is non-restrict <=> the function may choose  not to evaluate one or more of its args
*** Strict function always evaluates its arguments
*** thunk
    unevaluated form of an expression is called thunk
